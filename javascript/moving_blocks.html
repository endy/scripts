<!DOCTYPE html>
<html>
<head>
<title>Move Blocks Prototype</title>

<script type="text/javascript">

// UTILITIES
function clamp(value, min, max)
{
    return (value < min) ? min : 
                          (max < value) ? max : 
                                          value;
}

// TYPES
function Point(x, y)
{
    this.x = x;
    this.y = y;
}

function updateBlock()
{
    var selectedBlock = null; 
      
    //for (i = 0; i < gEntities.length; i++)
    { 
      //  var b = gEntities[i];
        if (this.selected == true)
        {
            selectedBlock = this;
            //break;  // look no further, can only select one block at a time and we already have this one.
        }     
        else if (gMouseState.leftButtonPressed == true)
        {
            b = this;
             // implement update check
            if (b.pos.x <= gMouseState.pos.x &&
                gMouseState.pos.x < b.pos.x + b.width &&
                b.pos.y <= gMouseState.pos.y &&
                gMouseState.pos.y < b.pos.y + b.height)
            {
                    selectedBlock = b;
            }     
        }
    }  

    if (selectedBlock != null)
    {
        if (gMouseState.leftButtonPressed == true)
        {
            selectedBlock.pos = new Point(gMouseState.pos.x - (selectedBlock.width / 2),
                                      gMouseState.pos.y - (selectedBlock.height / 2));
            selectedBlock.selected = true;
        }
        else
        {
            selectedBlock.selected = false;

            // Snap block to grid based on block center
            // todo: add a highlight where the block will drop, instead of blind snapping
            selectedBlock.pos.x -= ((selectedBlock.pos.x +20) % 40) - 20;
            selectedBlock.pos.y -= ((selectedBlock.pos.y +20) % 40) - 20;
        }
    }
}

function Block(x, y)
{
    this.pos    = new Point(x,y); 
    this.width  = 40; 
    this.height = 40;

    this.draw = function(canvasCtx)
    {
        canvasCtx.fillStyle = "blue";
        canvasCtx.fillRect(this.pos.x, this.pos.y, this.width, this.height);

        canvasCtx.fillStyle = "white";
        canvasCtx.font = "30px Arial";
        canvasCtx.fillText("1", this.pos.x+10, this.pos.y+30);  
    }

    this.update = updateBlock; 
}

function Ant(x, y)
{
    this.pos = new Point(x,y);
    this.dir = new Point(4,4);

    this.draw = function(canvasCtx)
    {
        canvasCtx.fillStyle = "black";
        canvasCtx.fillRect(this.pos.x, this.pos.y, 10, 10);
    }

    this.update = function()
    {
        this.pos.x += this.dir.x;
        this.pos.y += this.dir.y;

        if (this.pos.x < 0 || 800 < this.pos.x)
        {
            this.dir.x *= -1;
            this.pos.x = clamp(this.pos.x, 0, 800);
        }
        if (this.pos.y < 0 || 600 < this.pos.y)
        {
            this.dir.y *= -1;
            this.pos.y = clamp(this.pos.y, 0, 600);
        }
    }
}

///////////////////////////////////////////
// GLOBALS
var gUIEntities       = [];
var gDrawableEntities = [];
var gEntities         = [];

var gKeyState = { keys:{} };

var gMouseState = { pos:new Point(0,0),
                    prevPos:new Point(0,0),
                    valid:false,
                    leftButton:0,
                    leftButtonPressed:false,
                    rightButton:false,
                    rightButtonPressed:false};

function loadResources()
{
    // blockImage = new Image();
    // blockImage.src = "some_block.png";
}


function createEntities()
{
    // create all game entities
    // for each entity
    //    create the object
    //    add it to a UI list if interactive
    //    add it to a draw list if drawable
    //    add it to an update list if has internal update needs (should be all entities)

    var blocks = [new Block(80, 80), new Block(480, 480), new Block(360, 200) ];
   
    for (i = 0; i < blocks.length; i++)
    {
        gEntities.push(blocks[i]);
        gDrawableEntities.push(blocks[i]);
    }

    var ants = [new Ant(30,30), 
                new Ant(400,200),
                new Ant(700, 10),
                new Ant(300, 580),
                new Ant(100, 300)];

    for (i = 0; i < ants.length; i++)
    {
        gEntities.push(ants[i]);
        gDrawableEntities.push(ants[i]);
    }
}

function updateEntities()
{
    for (i = 0; i < gEntities.length; i++)
    {
        gEntities[i].update();
    }
            

    for (k in gKeyState.keys)
    {
        if (gKeyState.keys[k] == 1)
        {
            console.log(k);
        }
    }
}

function drawUI(ctx)
{

}
function drawGrid(ctx)
{
    var screenWidth = document.getElementById('screen').width;
    var screenHeight = document.getElementById('screen').height;
    var verticalLines = screenWidth / 40;
    var horizontalLines = screenHeight / 40;

    for (var i = 1; i < verticalLines; i++)
    {
        ctx.beginPath();
        ctx.moveTo(i*40, 0);
        ctx.lineTo(i*40, screenHeight);
        ctx.stroke();
    }
    for (var i = 1; i < horizontalLines; i++)
    {
        ctx.beginPath();
        ctx.moveTo(0,           i*40);
        ctx.lineTo(screenWidth, i*40);
        ctx.stroke();
    }
}

function drawWorld()
{
    canvas = document.getElementById('screen');
    var ctx = canvas.getContext('2d');

    var b = Block(10, 10);

    if (ctx)
    {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = "grey";
        ctx.fillRect(0, 0, canvas.width, canvas.height); 

        drawGrid(ctx);

		for (i = 0; i < gDrawableEntities.length; i++)
		{
            var e = gDrawableEntities[i];
            e.draw(ctx);   
		}

        // refactor this out of drawWorld
        drawUI(ctx);
    }

    var worldLogString =  "MousePos: (" + gMouseState.pos.x + ", " + gMouseState.prevPos.y + ")";

   

    var worldLog = document.getElementById("worldLog");
    worldLog.innerHTML = worldLogString;
}

function screenClicked()
{
    var canvas = document.getElementById('screen');
    var rect = canvas.getBoundingClientRect();

    var mouseLoc = { x:(event.clientX-rect.left),
                     y:(event.clientY-rect.top)   };

}

function updateMouse()
{
    gMouseState.prevPos = new Point(gMouseState.pos.x, gMouseState.pos.y);
}

function screenMouseMove()
{
    var canvas = document.getElementById('screen');
    var rect = canvas.getBoundingClientRect(); 
    gMouseState.pos = new Point(event.clientX-rect.left, event.clientY-rect.top);
}

var lastDownTarget = 0;
function mouseDown(event)
{
    lastDownTarget = event.target;
    gMouseState.leftButtonPressed = true;  
}

function mouseUp()
{
    gMouseState.leftButtonPressed = false;   
}

function mouseLeave()
{ 
    gMouseState.valid = 0;
}
function mouseEnter()
{
    
    gMouseState.valid = 1;
}
var message = "";
function keyDown(event)
{
    if (65 <= event.keyCode && event.keyCode < 91)
    {
        var c = String.fromCharCode(event.keyCode);
        message += c;
        gKeyState.keys[c] = 1;
    }
    else if (event.keyCode == 13)
    {
        document.getElementById("uiLog").innerHTML = message;
        message = "";
    }
}

function keyUp(event)
{
    if (65 <= event.keyCode && event.keyCode < 91)
    {
        var c = String.fromCharCode(event.keyCode);
        gKeyState.keys[c] = 0;
    }
}

function updateWorld()
{
    updateMouse();

    updateEntities();

    drawWorld();
}

function initApp()
{
    loadResources();
    createEntities();

    var canvas = document.getElementById('screen');
    document.addEventListener('mousedown', function(event) {mouseDown(event); }, false);
    document.addEventListener('keydown', function(event) { if (lastDownTarget == canvas){ keyDown(event); }} , false); 
    document.addEventListener('keyup', function(event) { if (lastDownTarget == canvas){ keyUp(event); }} , false);
  
    setInterval(updateWorld, 1000/60);
}

</script>
</head>

<body onload="initApp();">
<button onclick="alert('I do nothing!');">NULL</button>
<br />
<span id="Output"></span>

<div>
    <canvas id="screen" onmousemove="screenMouseMove()"
                        onmouseup="mouseUp()" 
                        onmouseleave="mouseLeave()" 
                        onmouseenter="mouseEnter()"
                        width="800" height="600">
    HTML5 Canvas unsupported
    </canvas>
    <div>World Log:<span id="worldLog"></span></div>
    <div>UI Log:<span id="uiLog"></span></div>
    <div>Graphics Log:<span id="graphicsLog"></span></div>
</div>
</body>
</html>
